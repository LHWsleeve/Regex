# 正则指引
---
## 第一章 字符组（在同一个位置可能出现的各种字符）
  - 1.1 普通字符组（[]）：
正则表达式的范围表示法：用[0-9]表示[0123456789]，  本质是ascill码的码值（-范围表示法中可以同时
，<font color=#00ffff>并列多个范围[0-9a-zA-Z]</font>


- 1.2  元字符和转义：
元字符：‘-’表示范围而不是字符本身
除非使用转义字符  ‘  \’　　　　  (^[0\\-9]$)
[]是成对出现的，否则，最近匹配法或者用专一字符处理多余的 []

　　
- 1.3 排除型字符组（排除型字符组必须匹配一个字符）：
在方括号之前紧跟一个脱字符^,[^0-9]表示除了匹配０-９范围之外的数（非数值字符）

- 1.4 字符组简记法：
\d = [0-9]　\w = [0-9a-zA-Z<font color=#00ffff>_</font>] 　\s = [\t\r\n\v\f]（第一个字符是空格）
 *同理有\D,\W,\S,是对应的排除型字符组。[\s\S]可以表示匹配任意字符*

- 1.5 POSIX字符组：
为unix/linux设计的字符组。（暂时不管）


## 第二章 量词

 - 2.1
 \d, 可以匹配单个数字，当纯粹的数字匹配的时候可以使用量词，\d{6}
 量还可以表示不确定的长度\d{m,n}（n前面不能有空格)
 量词简记法:

 常用|等价
 -|-
 *|{0,}
 +|{1,}
 ?|{0,1}
- 2.2
数据提取:
```
print re.search(r"\d{6}", "ac123456cd").group(0)
输出：123456
```
- 2.3 点号（.）
点号可以匹配任意字符（除了换行符\n）,可以使用[|s\S]来自制涵盖所有字符。
点号滥用会出现问题。（<font color=#00ffff>由于正则匹配的匹配优先量词规则/贪婪量词</font>，适合解析路径）
```
print re.search(r"\".*\"", "\"quote " and another\"")
输出："quote " and another\"
多一个双引号
```
- 2.3 忽略优先量词匹配
如果不确定要不要匹配，先不匹配，尝试表达式之后的元素，如果尝试失败，在回溯。(适合提取头尾固定，中间内容不固定并且有换行符的)

常用|等价|忽略优先量词
-|-|-
*|{0,}|*?
+|{1,}|+?
?|{0,1}|??
 - 2.4 转义

 常用|忽略优先量词|转义形式
-|-|-
*|*?|\\*\\?
+|+?|\\+\\?
?|??|\\?\\?
{n}|null|\\{n}
{m,n}|null|\\{m,n}
{m,}|null|\\{m,}
.|null|\\.

# 第三章 括号
- 3.1 分组和多选结构  
**分组**：使用括号，如果用量词限定出现次数的元素不是字符组或字符，而是连续的几个字符甚至子表达式，
用括号编程一个整体。例如：（ab）+：表示字符串ab重复出现一次以上。
[1-9]\d{14}(\d{2}[0-9x])?:[1-9]表示第一个字为字符组，\d{14}表示其后有十四个数字，(\d{2}[0-9x])?:
表示是否存在[两个数字和（一个0-9或x的数）]---→用来匹配身份证号（存在15位和18位）  
**多选结构**：（...|...)结构。括号内用竖线|分隔开多个子表达式，子表达式没有数目限制，只要满足一个就能匹配成功
，类似于switch？
身份证[1-9]\d{14}(\d{2}[0-9x])?---→([1-9]\d{14}|[1-9]\d{14}\d{2}[0-9x])  
**用正则表达式匹配数值在某个范围内的字符串：例如IPv4 匹配一段数值在0-255之间的数**

情况|正则式
-|-
如果1位数，那么对数字没有限制|[0-9]
如果2位数，无限制|[0-9]{2}
如果三位数：|
1.如果第一位数字是1，那么2,3为数字无限制|1[0-9]{2}
如果第1位数字是2，第二位是0-4，第三位无限制|2[0-4][0-9]
如果第1位数字是2，第二位是5，那么的第三位数字只能是0-5|25[0-5]

匹配日月小时分钟，手机号码同上
匹配手机号：(0|\+86)?(13[0-9])|15[0-356]|18([025-9])\d{8},头部的0、+86，以及多个号段匹配和后八位无限制
- 3.2 引用分组
分组表达存入不同的编号，然后用group(num)提取，例如提取年月日（2010-12-22）：
```
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(1)
2012
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(2)
12
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(3)
22
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(0)     0是默认编号组
2012-12-22
```
-
  - 3.2.1  反向引用  
  反向引用允许在真正则表达式内部引用之前的捕获分组匹配的文本，其形式也是\num。通过反向引用建立先后联系
这样后半部分可以知道前半部分的结果，进行判断是否重写。
匹配重叠字母，例如boot。([a-z]\1)：\1来反向引用，第一个字符是a-z之间的一个字母，第二个字符是反向引用num=1，即前者字母。  
**反向引用可能出现二义性**，比如\10，是替换第一个分组+0，还是替换第10个分组，如果出现则是后者。为了解决二义性出现了**命名分组**  
**命名分组**:Python中用（？P\<name>regx)表示，name是命名，regx是正则表达式。同时命名分组保留数字编号。

- 3.3 非捕获分组  
由于一旦出现括号，正则表达式都会将其保存生成引用，而有些引用分组不会用到，非捕获分组就是在用不到的括号内，
加上例如(?:xxx)，则这个括号不会被计入引用。
  用法特殊，不常用。
- 3.4 **转义**  
元字符单个出现的都需要转义，例如*,+,?,如果元字符成对出现需要全部转义。
  对于括号(,)和,|，必须全部转义，不论左括号还是右括号。

#第四章 断言
（单词边界.行起始/结束为止、环视）
- 4.1 单词边界  
在进行单词替换的时候，需要确定替换的是“整个单词”还是“字符串中的一部分”。为了解决这个问题，正则表达式提供了单词边界“\b”
匹配单词边界的位置

字符串|\brow\b|\brow|row\b
-|-|-|-
tomorrow|null|null|√
brown|null|null|null
row|√|√|√
rowdy|null|√|null
表达式说明|只能是单词row|\b的右侧是单词字符，所以左侧不能是单词字符（xx+row）|\b的左侧是单词字符，所以右侧不能是单词字符（row+xx）
甚至可以提取单词：\w匹配[0-9a-zA-Z_]
```
print re.findall(r"\b\w+\b", "a sentence\tcontains a lot of words")
['a','sentence','contains','a','lot','of','words']
```
- 4.2 行起始位置/结束位置  （^,$)  
匹配位置的元素叫做锚点。我们用^$来匹配字符串的开始位置和结束位置，用来判断"整个字符串能否由表达式匹配" ^可以吧整个表达式匹配定位在字符串头
即便字符串其他位置也能匹配，也失败。  
^可以设置为***多行模式***，就可以匹配整个字符串的起始位置，也可以匹配换行符之后的位置使用(？m)^，虽然这里有括号但是不会作为捕获分组。可以用来***提取每行第一个单词***  
***$***：通常匹配的是整个字符串的结尾位置---如果最后是行终止符，则匹配行终止符之前的位置；否则匹配最后一个字符之后的位置。
即：当强制要求匹配字符串的时候，正则规则在头尾加上^$，表示完全匹配。  
**注**：在密码匹配时使用\z替换$　　

- 4.3 环视  (从文本中提取有长度特征的数据)  
旁边文本必须满足一定条件，但不需要匹配。<(?!/)是一个环视文本，(?!...)是结构标识，/是真的表达式。表示，“当前位置之后（右侧），不允许出现/能匹配的文本”。

**环视分类**
名字|记法|判断方向|结构内表达式匹配成功返回值
-|-|-|-
肯定顺序环视|(?=...)|向右|Ture
否定顺序环视|(?!...)|向右|False
肯定逆序环视|(?<=...)|向左|Ture
否定逆序环视|(?<!=)|向左|False
例如\d{3}:  
(?=\d{3})|(?!\d{3})|(?<=\d{3})|(?<!\d{3})
-|-|-|-
右侧必须出现三个数字|左侧必须出现三个数字|右侧不能出现三个数字|左侧不能出现三个数字

- 4.4 环视支持程度  
基本都支持顺序环视，逆序环视有区别  
python：逆序环视的表达式能匹配的文本长度必须是固定的(不确定也不行)  
  
  例如：(?<=dog)，(?<=(dog|cats))合法，(?<=dog?)不合法，？表示是否存在，(?<=(dog|cats))不合法，因为匹配文字长度不确定。  
上述不合法问题可以用多选结构解决  
  
  例如: (?<=dog?)---→（(?<=dog)|(?<=dogs)),，(?<=(dog|cats))---→，((?<=dog)|(?<=cats))  
    
    Java:逆序环视中， 能匹配的文本可以没有确定长度，但是必须有上限。  
        
  例如：(?<!(dogs?|cats?))合法, 但是(?<!(dogs!){3,})不合法  
  - 4.5 环视组合（ToDo)
  
  

  
  
  - 4.6 ***注***:反向引用不会保留断言的判断。  
  例如：验证单词cat是否在字符中出现了两次。(\bcat\b)\s+\b\1\b.才是正确的。(\bcat\b)\s+\1，是不对的，反向引用时之前的断言都会被忽略，
  后者在例如"cat cate"中会匹配True(出现量词cat )  
  
# 第五章  匹配模式 
- 5.1 不区分大小写模式与模式的指定方式  
  通常用户关心的只是文本的意义，而不是具体形式。比如，不关心大小写。  
  通常有两种办法指定匹配模式，以**模式修饰符**，或者以**预定义的常量**作为特殊的参数传入来指定。  
  - 5.1.1模式修饰符即模式名称对应的单个字符，使用时将其填入特定结构 **(?modifier)** ---→modifier表示模式修饰符(不同的要求有不同的字符，比如不区分大小事的修饰符是i)  
  例如：不区分the的大小写---→(?!)the  
  ***在各语言中较为通用，一般用这个***
  - 5.1.2 使用预定义的常量作为参数。
  
  语言|常量
  -|-
  java|Pattern.CASE_INSENSITIVE
  Python|re.I;、     re.IGNORECASE

- 5.2 单行模式  
元字符.几乎能匹配任何字符，除了换行符\n。当匹配多行文本时不能单纯用.来匹配，可以用[\s\S]来匹配。或者正则中提供了**单行模式**。  
单行模式对应的修饰符是s（Single line)，如果用模式修饰符，则在表达是开头使用(?s)。

语言|常量
-|-
Java|Pattern.DOTALL
Python|re.S;re.DOTALL

- 5.3 多行模式  
**注**：多行模式与单行模式没有任何关系。  
单行模式影响的是点号的匹配规则：即单行模式下，点好.可以匹配包括换行符在内的任何字符。  
多行模式影响的是^和$的匹配规则：在默认模式下，^$匹配的是整个字符串的起始位置和结束位置，但在多行模式下他们也能匹配字符串内某一行文本的起始位置和结束位置。    
比如：要求匹配多行文本中，所有以数字字符开头的行。为了解决这个问题，尝试匹配一个数字字符，若成功，则匹配一行。  
多行模式修饰符是m(Multiline)，开头用(?M)，这样^可以定位到每一行内部的其实哈那个。  

语言|常量
-|-
Java|Pattern.MULTILINE
Python|re.m；re.MULTILINE

- 5.4 注释模式  
正则表达式过于复杂允许添加注释。使用(?#comment)添加注释。注释模式下，正则表达式内部的空白字符都被忽略。注释则以#commment的形式添加在内部。  
比如： ((?x)(\d{4})-(\d{2})-(\d{2})) 表示为  
dateRegex = r"""  
(?x) #enable mutiline and extened mode **注**：这个模式修饰符是，宽松格式模式  
(# start  
 (\d{4})#year  
  -# dash  
  (\d{2})#month  
  -#dash  
  (\d{2})#day  
  )$end opof whoe regex  
  """
  
语言|常量
-|-
Java|Pattern.COMMENT
python|re.X;re.VERBOSE

- 5.5 更多模式  
  - 5.5.1 修饰符的作用范围  （python不能用）
  常见的修饰符是(?modifier),塔比嗾使开始使用某一个模式，一般放在开头，表示整个表达式都生效。当放在表达式当中的时候，则表示模式从这里开始生效；
  如果模式修饰符出现在某个括号内---→比如((?modifier)...)那么它的范围只限于括号内部，也可以记为(?modifier:...)  

  正则表达式|能匹配的文本
  -|-
  t(?i)he|tHe the tHE tHE
  th(?i)e|thE the
  t((?i)h)e = t(?i:h)e|tHe the
     - 5.5.2 失效修饰符(python不支持)  
     (?modifier)指定匹配模式开始作用的范围。则(?-modifier)来指定某个模式生效到此为止。  
     待定
     - 5.5.3 模式与反向引用  （Java可以)  
     反向引用：引用之前表达式匹配的文本。如果之前的表达式使用了某种模式，引用时是否会继承这种模式。  
     待补充  
     - 5.5.4 冲突策略  
     使用(-?modifier)可以终止某个模式的作用范围；但是也可以通过与定义常量来指定，可能产生冲突。  
     
        例如同时使用(?-i)取消不区分大小写模式，又使用与定义常量(比如java中的Pattern.CASE_INSENSITIVE)指定整个表达式不区分大小写模式。
     
       实际使用上***模式修饰符具有更高的优先级***。
       
    # 第六章 其他  
- 6.1 转义  
正则表达式不等于字符串，原生字符串(r")才可以作为正则表达式

字符串文字|字符串/正则文字|正则表达式|说明
-|-|-|-
 \\\n|\n|换行符|
 \n|换行符|换行符|
\\\t|\t|制表符
 \t|制表符|制表符
 \\\\\\\\|\\\\|\\|反斜线字符
 
 字符串文字中\\\\n和\\n表示的是同一个字符，只是前者先做字符喜欢转移，再做正则转义。
 而后者只做了字符串转义。但是**正则表达式中的\\字符串文字必须写成\\\\\\\\**。  
 
 <font color=#FF0000>***注***：如果字符串最前面加了***r***，则就会表示输入的字符串是正则文字，是原始字符串。如果不加***r***，每个\都需要转义。</font>  
 **r/R:非转义的原始字符串 \***    
 与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。 
以r开头的字符，常用于正则表达式，对应着re模块。  

 第一：<font color=#FF0000>所以能使用原生字符串，也就是完全忽略字符转移的特殊用字符串r"regex",尽量用。</font>  
 第二： 如果确定必须使用字符串文字，坚持正则表达式中的每个反斜杠在字符串文字中都要写成 <font color=#FF000>\\\\</font>只有\n和\t例外，原因如上图表格。  
 
- 6.1 彻底消除元字符的特殊含义  
在需要消除元字符特殊含义的正则表达式两端添加\Q和 \E，也就是\Q....\E，如果有\Qca*t\E，这个匹配会忽略*的作用。并且\Q....\E只对内部生效。  
另外，部分语言提供专门函数提供消除元字符含义。  

语言|函数
-|-
Python|re.escape(text)
Java|Pattern.quote(text)

- 6.1 字符组的转义  
在字符组内部，只有三个字符需要转义。1.闭方括号]2.横线-，不表示范围仅表示-本身时。[0\\-9]等价于[-09]。3.需要转义的字符^，如果他不是用于排除性字符组([^ab])，则应当写成\\^，比如[\\^ab]，
如果^不仅跟在开括号[之后，那就不需要转义，比如[a^b],[ab^]等。  

- 6.2 正则表达式的处理形式  
   - 6.2.1 函数是处理  
   python中，常见的表达式操作都有对应的函数(查找，替换等)，执行这些操作时调用对应函数，将正则表达式和字符串作为参数传入。
   - 6.2.2 面向对象式处理  
   Java之类的语言中，正则表达式采取了不同的处理形式：进行正则表达式处理之前，必须生成专门的正则表达式对象，在调用此对象的成员函数。
   ```  
   Pattern pattern = Pattern.compile("\\d+");
   Matcher matcher = pattern.matches("123 45 6");
   while(matcher.find()){
   // do as you wish
   }
   ```  
  - 6.2.3 比较  
  函数式方式简单，但是隐去了正则表达式生成过程，容易出错，适合单次使用。面向对象方式繁琐，更安全，适合重复使用。Python和Java都有函数式和面向对象式方法。  
   
   - 6.3.4 线程安全  
   多线程可以共享一个正则表达式对象，节省时间；<font color=#FF0000>但操作不同文本时，应当针对各个线程生成不同的匹配对象</font>  
   
- 6.3 表达式中的优先级  
正则表达式元素之间的组合关系只有四种：

关系|表达式
-|-   
普通拼接|abc
括号|(abc)
量词|a*b
多选结构|ab\|cd

正则表达式中的优先级  
优先级|组合|说明
-|-|-
1|(regex)|整个括号内的子表达式成为单个元素
2|*?+|限定之前紧邻的元素
3|abc|普通拼接，元素相继出现
4|a\|bc|多选结构  

- 6.4 回车和换行  
回车\\r和换行\\n，区别源于历史原因，机械打字机时代，打完一行后，先"回车"让打印头回到起始点，然后"换行"让打印纸向上移一格，否则会两行重复。
现代历史不会再出现这种问题。