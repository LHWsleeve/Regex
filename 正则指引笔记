# 正则指引
---
## 第一章 字符组（在同一个位置可能出现的各种字符）
  - 1.1 普通字符组（[]）：
正则表达式的范围表示法：用[0-9]表示[0123456789]，  本质是ascill码的码值（-范围表示法中可以同时
，<font color=#00ffff>并列多个范围[0-9a-zA-Z]</font>


- 1.2  元字符和转义：
元字符：‘-’表示范围而不是字符本身
除非使用转义字符  ‘  \’　　　　  (^[0\\-9]$)
[]是成对出现的，否则，最近匹配法或者用专一字符处理多余的 []

　　
- 1.3 排除型字符组（排除型字符组必须匹配一个字符）：
在方括号之前紧跟一个脱字符^,[^0-9]表示除了匹配０-９范围之外的数（非数值字符）

- 1.4 字符组简记法：
\d = [0-9]　\w = [0-9a-zA-Z<font color=#00ffff>_</font>] 　\s = [\t\r\n\v\f]（第一个字符是空格）
 *同理有\D,\W,\S,是对应的排除型字符组。[\s\S]可以表示匹配任意字符*

- 1.5 POSIX字符组：
为unix/linux设计的字符组。（暂时不管）


## 第二章 量词

 - 2.1
 \d, 可以匹配单个数字，当纯粹的数字匹配的时候可以使用量词，\d{6}
 量还可以表示不确定的长度\d{m,n}（n前面不能有空格)
 量词简记法:

 常用|等价
 -|-
 *|{0,}
 +|{1,}
 ?|{0,1}
- 2.2
数据提取:
```
print re.search(r"\d{6}", "ac123456cd").group(0)
输出：123456
```
- 2.3 点号（.）
点号可以匹配任意字符（除了换行符\n）,可以使用[|s\S]来自制涵盖所有字符。
点号滥用会出现问题。（<font color=#00ffff>由于正则匹配的匹配优先量词规则/贪婪量词</font>，适合解析路径）
```
print re.search(r"\".*\"", "\"quote " and another\"")
输出："quote " and another\"
多一个双引号
```
- 2.3 忽略优先量词匹配
如果不确定要不要匹配，先不匹配，尝试表达式之后的元素，如果尝试失败，在回溯。(适合提取头尾固定，中间内容不固定并且有换行符的)

常用|等价|忽略优先量词
-|-|-
*|{0,}|*?
+|{1,}|+?
?|{0,1}|??
 - 2.4 转义

 常用|忽略优先量词|转义形式
-|-|-
*|*?|\\*\\?
+|+?|\\+\\?
?|??|\\?\\?
{n}|null|\\{n}
{m,n}|null|\\{m,n}
{m,}|null|\\{m,}
.|null|\\.

# 第三章 括号
- 3.1 分组和多选结构  
**分组**：使用括号，如果用量词限定出现次数的元素不是字符组或字符，而是连续的几个字符甚至子表达式，
用括号编程一个整体。例如：（ab）+：表示字符串ab重复出现一次以上。
[1-9]\d{14}(\d{2}[0-9x])?:[1-9]表示第一个字为字符组，\d{14}表示其后有十四个数字，(\d{2}[0-9x])?:
表示是否存在[两个数字和（一个0-9或x的数）]---→用来匹配身份证号（存在15位和18位）  
**多选结构**：（...|...)结构。括号内用竖线|分隔开多个子表达式，子表达式没有数目限制，只要满足一个就能匹配成功
，类似于switch？
身份证[1-9]\d{14}(\d{2}[0-9x])?---→([1-9]\d{14}|[1-9]\d{14}\d{2}[0-9x])  
**用正则表达式匹配数值在某个范围内的字符串：例如IPv4 匹配一段数值在0-255之间的数**

情况|正则式
-|-
如果1位数，那么对数字没有限制|[0-9]
如果2位数，无限制|[0-9]{2}
如果三位数：|
1.如果第一位数字是1，那么2,3为数字无限制|1[0-9]{2}
如果第1位数字是2，第二位是0-4，第三位无限制|2[0-4][0-9]
如果第1位数字是2，第二位是5，那么的第三位数字只能是0-5|25[0-5]

匹配日月小时分钟，手机号码同上
匹配手机号：(0|\+86)?(13[0-9])|15[0-356]|18([025-9])\d{8},头部的0、+86，以及多个号段匹配和后八位无限制
- 3.2 引用分组
分组表达存入不同的编号，然后用group(num)提取，例如提取年月日（2010-12-22）：
```
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(1)
2012
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(2)
12
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(3)
22
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(0)     0是默认编号组
2012-12-22
```
-
  - 3.2.1  反向引用  
  反向引用允许在真正则表达式内部引用之前的捕获分组匹配的文本，其形式也是\num。通过反向引用建立先后联系
这样后半部分可以知道前半部分的结果，进行判断是否重写。
匹配重叠字母，例如boot。([a-z]\1)：\1来反向引用，第一个字符是a-z之间的一个字母，第二个字符是反向引用num=1，即前者字母。  
**反向引用可能出现二义性**，比如\10，是替换第一个分组+0，还是替换第10个分组，如果出现则是后者。为了解决二义性出现了**命名分组**  
**命名分组**:Python中用（？P\<name>regx)表示，name是命名，regx是正则表达式。同时命名分组保留数字编号。

- 3.3 非捕获分组  
由于一旦出现括号，正则表达式都会将其保存生成引用，而有些引用分组不会用到，非捕获分组就是在用不到的括号内，
加上例如(?:xxx)，则这个括号不会被计入引用。
  用法特殊，不常用。
- 3.4 **转义**  
元字符单个出现的都需要转义，例如*,+,?,如果元字符成对出现需要全部转义。
  对于括号(,)和,|，必须全部转义，不论左括号还是右括号。

#第四章 断言
（单词边界.行起始/结束为止、环视）
- 4.1 单词边界  
在进行单词替换的时候，需要确定替换的是“整个单词”还是“字符串中的一部分”。为了解决这个问题，正则表达式提供了单词边界“\b”
匹配单词边界的位置

字符串|\brow\b|\brow|row\b
-|-|-|-
tomorrow|null|null|√
brown|null|null|null
row|√|√|√
rowdy|null|√|null
表达式说明|只能是单词row|\b的右侧是单词字符，所以左侧不能是单词字符（xx+row）|\b的左侧是单词字符，所以右侧不能是单词字符（row+xx）
甚至可以提取单词：\w匹配[0-9a-zA-Z_]
```
print re.findall(r"\b\w+\b", "a sentence\tcontains a lot of words")
['a','sentence','contains','a','lot','of','words']
```
- 4.2 行起始位置/结束位置  （^,$)  
匹配位置的元素叫做锚点。我们用^$来匹配字符串的开始位置和结束位置，用来判断"整个字符串能否由表达式匹配" ^可以吧整个表达式匹配定位在字符串头
即便字符串其他位置也能匹配，也失败。  
^可以设置为***多行模式***，就可以匹配整个字符串的起始位置，也可以匹配换行符之后的位置使用(？m)^，虽然这里有括号但是不会作为捕获分组。可以用来***提取每行第一个单词***  
***$***：通常匹配的是整个字符串的结尾位置---如果最后是行终止符，则匹配行终止符之前的位置；否则匹配最后一个字符之后的位置。
即：当强制要求匹配字符串的时候，正则规则在头尾加上^$，表示完全匹配。  
**注**：在密码匹配时使用\z替换$　　

- 4.3 环视  (从文本中提取有长度特征的数据)  
旁边文本必须满足一定条件，但不需要匹配。<(?!/)是一个环视文本，(?!...)是结构标识，/是真的表达式。表示，“当前位置之后（右侧），不允许出现/能匹配的文本”。

**环视分类**
名字|记法|判断方向|结构内表达式匹配成功返回值
-|-|-|-
肯定顺序环视|(?=...)|向右|Ture
否定顺序环视|(?!...)|向右|False
肯定逆序环视|(?<=...)|向左|Ture
否定逆序环视|(?<!=)|向左|False
例如\d{3}:  
(?=\d{3})|(?!\d{3})|(?<=\d{3})|(?<!\d{3})
-|-|-|-
右侧必须出现三个数字|左侧必须出现三个数字|右侧不能出现三个数字|左侧不能出现三个数字

- 4.4 环视支持程度  
基本都支持顺序环视，逆序环视有区别  
python：逆序环视的表达式能匹配的文本长度必须是固定的(不确定也不行)  
  
  例如：(?<=dog)，(?<=(dog|cats))合法，(?<=dog?)不合法，？表示是否存在，(?<=(dog|cats))不合法，因为匹配文字长度不确定。  
上述不合法问题可以用多选结构解决  
  
  例如: (?<=dog?)---→（(?<=dog)|(?<=dogs)),，(?<=(dog|cats))---→，((?<=dog)|(?<=cats))  
    
    Java:逆序环视中， 能匹配的文本可以没有确定长度，但是必须有上限。  
        
  例如：(?<!(dogs?|cats?))合法, 但是(?<!(dogs!){3,})不合法  
  - 4.5 环视组合（ToDo)
  
  

  
  
  - 4.6 ***注***:反向引用不会保留断言的判断。  
  例如：验证单词cat是否在字符中出现了两次。(\bcat\b)\s+\b\1\b.才是正确的。(\bcat\b)\s+\1，是不对的，反向引用时之前的断言都会被忽略，
  后者在例如"cat cate"中会匹配True(出现量词cat)
    
