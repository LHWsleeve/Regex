# 正则指引
---
## 第一章 字符组（在同一个位置可能出现的各种字符）
  - 1.1 普通字符组（[]）：
正则表达式的范围表示法：用[0-9]表示[0123456789]，  本质是ascill码的码值（-范围表示法中可以同时
，<font color=#00ffff>并列多个范围[0-9a-zA-Z]</font>


- 1.2  元字符和转义：
元字符：‘-’表示范围而不是字符本身
除非使用转义字符  ‘  \’　　　　  (^[0\\-9]$)
[]是成对出现的，否则，最近匹配法或者用专一字符处理多余的 []

　　
- 1.3 排除型字符组（排除型字符组必须匹配一个字符）：
在方括号之前紧跟一个脱字符^,[^0-9]表示除了匹配０-９范围之外的数（非数值字符）

- 1.4 字符组简记法：
\d = [0-9]　\w = [0-9a-zA-Z<font color=#00ffff>_</font>] 　\s = [\t\r\n\v\f]（第一个字符是空格）
 *同理有\D,\W,\S,是对应的排除型字符组。[\s\S]可以表示匹配任意字符*

- 1.5 POSIX字符组：
为unix/linux设计的字符组。（暂时不管）


## 第二章 量词

 - 2.1
 \d, 可以匹配单个数字，当纯粹的数字匹配的时候可以使用量词，\d{6}
 量还可以表示不确定的长度\d{m,n}（n前面不能有空格)
 量词简记法:

 常用|等价
 -|-
 *|{0,}
 +|{1,}
 ?|{0,1}
- 2.2
数据提取:
```
print re.search(r"\d{6}", "ac123456cd").group(0)
输出：123456
```
- 2.3 点号（.）
点号可以匹配任意字符（除了换行符\n）,可以使用[|s\S]来自制涵盖所有字符。
点号滥用会出现问题。（<font color=#00ffff>由于正则匹配的匹配优先量词规则/贪婪量词</font>，适合解析路径）
```
print re.search(r"\".*\"", "\"quote " and another\"")
输出："quote " and another\"
多一个双引号
```
- 2.3 忽略优先量词匹配
如果不确定要不要匹配，先不匹配，尝试表达式之后的元素，如果尝试失败，在回溯。(适合提取头尾固定，中间内容不固定并且有换行符的)

常用|等价|忽略优先量词
-|-|-
*|{0,}|*?
+|{1,}|+?
?|{0,1}|??
 - 2.4 转义

 常用|忽略优先量词|转义形式
-|-|-
*|*?|\\*\\?
+|+?|\\+\\?
?|??|\\?\\?
{n}|null|\\{n}
{m,n}|null|\\{m,n}
{m,}|null|\\{m,}
.|null|\\.

# 第三章 括号
- 3.1 分组和多选结构
**分组**：使用括号，如果用量词限定出现次数的元素不是字符组或字符，而是连续的几个字符甚至子表达式，
用括号编程一个整体。例如：（ab）+：表示字符串ab重复出现一次以上。
[1-9]\d{14}(\d{2}[0-9x])?:[1-9]表示第一个字为字符组，\d{14}表示其后有十四个数字，(\d{2}[0-9x])?:
表示是否存在[两个数字和（一个0-9或x的数）]---→用来匹配身份证号（存在15位和18位）
**多选结构**：（...|...)结构。括号内用竖线|分隔开多个子表达式，子表达式没有数目限制，只要满足一个就能匹配成功
，类似于switch？
身份证[1-9]\d{14}(\d{2}[0-9x])?---→([1-9]\d{14}|[1-9]\d{14}\d{2}[0-9x])
**用正则表达式匹配数值在某个范围内的字符串：例如IPv4 匹配一段数值在0-255之间的数**

情况|正则式
-|-
如果1位数，那么对数字没有限制|[0-9]
如果2位数，无限制|[0-9]{2}
如果三位数：|
1.如果第一位数字是1，那么2,3为数字无限制|1[0-9]{2}
如果第1位数字是2，第二位是0-4，第三位无限制|2[0-4][0-9]
如果第1位数字是2，第二位是5，那么的第三位数字只能是0-5|25[0-5]

匹配日月小时分钟，手机号码同上
匹配手机号：(0|\+86)?(13[0-9])|15[0-356]|18([025-9])\d{8},头部的0、+86，以及多个号段匹配和后八位无限制
- 3.2 引用分组
分组表达存入不同的编号，然后用group(num)提取，例如提取年月日（2010-12-22）：
```
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(1)
2012
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(2)
12
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(3)
22
print re.search(r"(\d{4})-(\d{2})-(\d{2})",  "2012-12-22").group(0)     0是默认编号组
2012-12-22
```
-
  - 3.2.1  反向引用  
反向引用允许在真正则表达式内部引用之前的捕获分组匹配的文本，其形式也是\num。通过反向引用建立先后联系
这样后半部分可以知道前半部分的结果，进行判断是否重写。
匹配重叠字母，例如boot。([a-z]\1)：\1来反向引用，第一个字符是a-z之间的一个字母，第二个字符是反向引用num=1，即前者字母。
**反向引用可能出现二义性**，比如\10，是替换第一个分组+0，还是替换第10个分组，如果出现则是后者。为了解决二义性出现了**命名分组**
**命名分组**:Python中用（？P\<name>regx)表示，name是命名，regx是正则表达式。同时命名分组保留数字编号。

- 3.3 非捕获分组
犹豫一旦出现括号，正则表达式都会将其保存生成引用，而有些引用分组不会用到，非捕获分组就是在用不到的括号内，
加上例如(?:xxx)，则这个括号不会被计入引用。
  用法特殊，不常用。
- 3.4 **转义**
  元字符单个出现的都需要转义，例如*,+,?,如果元字符成对出现需要全部转义。
  对于括号(,)和,|，必须全部转义，不论左括号还是右括号。
